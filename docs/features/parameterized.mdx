---
sidebar_position: 6
sidebar_label: Parameterized Tests
---

import { JavaKotlinCodeBlock } from '@site/src/components/JavaKotlinCodeBlock';

# Parameterized Tests

AutoParams also supports **parameterized tests**, allowing you to execute the same test logic with multiple sets of input data. With AutoParams, you can seamlessly combine manually specified values with automatically generated test data—enabling both flexibility and convenience.

Here are some of the features you can use for parameterized tests.

## `@ValueAutoSource` Annotation

The `@ValueAutoSource` annotation is a simple yet powerful tool for writing parameterized tests with AutoParams.

<JavaKotlinCodeBlock>
```java
@ParameterizedTest
@ValueAutoSource(strings = { "Camera", "Candle" })
void testMethod(String name, Factory<Product> factory) {
    Product product = factory.get(
        freezeArgument("name").to(name)
    );
    assertTrue(product.getName().startsWith("Ca"));
}
```

```kotlin
@ParameterizedTest
@ValueAutoSource(strings = ["Camera", "Candle"])
fun testMethod(name: String, factory: Factory<Product>) {
    val product: Product = factory.get(
        freezeArgument("name").to(name)
    )
    assertTrue(product.name.startsWith("Ca"))
}
```
</JavaKotlinCodeBlock>

:::note

This feature depends on parameter name availability. See the note in the [One-time Customizations with DSL](./customization#customization-dsl) section for details.

:::

In this example, the test method is executed twice—once with `"Camera"` and once with `"Candle"` as the value of the `name` parameter. The `factory` parameter is resolved automatically by AutoParams and can be customized using the DSL, as shown with `freezeArgument`.

This enables the creation of test objects (`Product` in this case) that are partially controlled (e.g., a fixed name) and partially randomized (e.g., all other properties), striking a balance between specificity and variety.

The usage of `@ValueAutoSource` is similar to JUnit 5's `@ValueSource`, and it supports the following types of literal values:

- `short`
- `byte`
- `int`
- `long`
- `float`
- `double`
- `char`
- `boolean`
- `java.lang.String`
- `java.lang.Class`

## `@CsvAutoSource` Annotation

The `@CsvAutoSource` annotation lets you define repeated test inputs in CSV format, similar to JUnit 5’s @CsvSource. Any parameters not explicitly provided in the CSV rows will be automatically generated by AutoParams.

<JavaKotlinCodeBlock>
```java
@ParameterizedTest
@CsvAutoSource({
    "Product 1, 500",
    "Product 2, 10000"
})
void testMethod(String name, BigDecimal priceAmount, UUID id) {
    Product product = new Product(id, name, priceAmount);
    assertTrue(product.getName().startsWith("Product"));
}
```

```kotlin
@ParameterizedTest
@CsvAutoSource(
    "Product 1, 500",
    "Product 2, 10000"
)
fun testMethod(name: String, priceAmount: BigDecimal, id: UUID) {
    val product = Product(id, name, priceAmount)
    assertTrue(product.name.startsWith("Product"))
}
```
</JavaKotlinCodeBlock>

In this example, the `@CsvAutoSource` annotation provides values for the `name` and `priceAmount` parameters. The remaining parameter(`id`) is resolved automatically by AutoParams.

The test will run once for each line in the CSV input array—twice in this case—allowing you to repeat the same test logic with multiple fixed inputs while still benefiting from automatic value generation for the rest.

This approach makes it easy to test combinations of fixed and dynamic values in a concise and expressive way.

## `@MethodAutoSource` Annotation

The `@MethodAutoSource` annotation combines the features of JUnit 5’s `@MethodSource` and AutoParams’s `@AutoSource`. You can specify a method that provides test data, and AutoParams will fill in any remaining parameters automatically.

<JavaKotlinCodeBlock>
```java
@ParameterizedTest
@MethodAutoSource("testDataSource")
void testMethod(String name, BigDecimal priceAmount, UUID id) {
    Product product = new Product(id, name, priceAmount);
    assertTrue(product.getName().startsWith("Product"));
}

static Stream<Arguments> testDataSource() {
    return Stream.of(
        arguments("Product 1", new BigDecimal(500)),
        arguments("Product 2", new BigDecimal(10000))
    );
}
```

```kotlin
@ParameterizedTest
@MethodAutoSource("testDataSource")
fun testMethod(name: String, priceAmount: BigDecimal, id: UUID) {
    val product = Product(id, name, priceAmount)
    assertTrue(product.name.startsWith("Product"))
}

companion object {
    @JvmStatic
    fun testDataSource(): Stream<Arguments> {
        return Stream.of(
            arguments("Product 1", BigDecimal(500)),
            arguments("Product 2", BigDecimal(10000))
        )
    }
}
```
</JavaKotlinCodeBlock>

In this example, the `testDataSource` method provides values for the `name` and `priceAmount` parameters. The remaining parameter(`id`) is automatically resolved by AutoParams and provided as an argument to the test method.

This setup allows you to blend manually specified values with automatically generated ones, giving you both precision and variability in your parameterized tests.

## `@Repeat` Annotation

The `@Repeat` annotation allows you to run a test multiple times, generating fresh random values for unspecified parameters on each run.

<JavaKotlinCodeBlock>
```java
@ParameterizedTest
@ValueAutoSource(ints = { 1, 2, 3 })
@Repeat(5)
void testMethod(int a, int b) {
    Calculator sut = new Calculator();
    int actual = sut.add(a, b);
    assertEquals(a + b, actual);
}
```

```kotlin
@ParameterizedTest
@ValueAutoSource(ints = [1, 2, 3])
@Repeat(5)
fun testMethod(a: Int, b: Int) {
    val sut = Calculator()
    val actual = sut.add(a, b)
    assertEquals(a + b, actual)
}
```
</JavaKotlinCodeBlock>

In this example, the test is executed 15 times in total—five times for each of the values `1`, `2`, and `3` assigned to the parameter `a`. For each run, the value of `b` is automatically generated by AutoParams.

If you want AutoParams to generate values for **all** parameters and still repeat the test multiple times, you can combine `@AutoSource` with `@Repeat`.

<JavaKotlinCodeBlock>
```java
@ParameterizedTest
@AutoSource
@Repeat(10)
void testMethod(int a, int b) {
    Calculator sut = new Calculator();
    int actual = sut.add(a, b);
    assertEquals(a + b, actual);
}
```

```kotlin
@ParameterizedTest
@AutoSource
@Repeat(10)
fun testMethod(a: Int, b: Int) {
    val sut = Calculator()
    val actual = sut.add(a, b)
    assertEquals(a + b, actual)
}
```
</JavaKotlinCodeBlock>

This combination is useful when you want to explore a wider range of inputs and increase test coverage with minimal setup.
